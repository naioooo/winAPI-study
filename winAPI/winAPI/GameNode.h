#pragma once
#include <Windows.h>

#pragma region 객체지향
/*
객체지향 프로그래밍 OOP 오브젝트 오리엔티드 프로그래밍 object oriented programming
 기본적으로 코드의 재사용성이 높고 코드의 관리가 용이할 떄가 많다
 신뢰성이 높은 프로그래밍을 가능하게 하는 경우가 많다

객체지향 4대특징

1. 캡슐화
 객체의 속성을 보호하기 위해 사용
2. 상속
 객체지향에서의 상속은 하위로 내려갈수록 구체화되는것을 의미
 일반적인 상속은 재사용성과 확장성이 보장되는 경우가 많기에 사용빈도가 높다
 프로그램 구조에 대한 이해도를 향상시킬 수 있다
3. 다형성
 하나의 개체가 여러 형태로 변화하는 것을 의미한다
 overriding 
4. 추상화 ####
  공통적인 부분과 특정 특성을 분리/추출해 재조합과 재구성을 하는 행위를 뜻한다

  ####
객체지향 5대 설계 원칙 SOLID RCSSI

1. SRP 단일 책임의 원칙
 결합도는 낮추고 응집도를 높여야한다
  결합도
   모듈간의 상호 의존 정도를 나타내는 지표
   결합도가 낮으면 상호 의존성이 줄어 재사용및 유지보수에 유리

  응집도
   하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성이라고 함
   응집도가 높은 모듈은 하나의 책임에 집중할 수 있고 독립성이 높아지기에 재사용과 유지보수에 유리

 상속과 오버라이딩을 사용한다면 평균이상은 간다
2. OCP 개방폐쇄의 원칙
 자신의 확장에는 열려있고 주변의 변화에 대해서는 닫혀있어야한다
 상위 클래스 또는 인터페이스를 중간에 두어 변화에는 폐쇄하고 인터페이스는 외부의 변화에대해 확장성을 개방한다
3. LSP 리스코브 치환의 원칙
 하위 타입은 언제나 자신의 기반인 상위타입으로 교체 할 수 잇어야 한다
4. ISP 인터페이스 분리의 원칙
 클라이언트는 자신이 사용하지 않는 함수 / 메서드에 의존 관계를 맺으면 안된다
 인터페이스를 각 기능을 분리하여 사용하는 함수 /메서드에만 의존관계 형성
 본인이 만드는 프로젝트 요구사항과 설계에 따라서 srp isp 중 1개를 선택해야하는 경우가 발생
5. DIP 의존관계 역전의 원칙
 자신보다 변화가 쉬운 것에 의존하지 말아야한다
  
*/
#pragma endregion


class GameNode
{
public:
	//HRESULT : 함수가 성공적으로 실행됐는지 체크하는 반환형 (양수 : true, 음수 : false)
	virtual HRESULT init(void);
	virtual void release(void);
	virtual void update(void);
	virtual void render(HDC hdc);
	virtual void input();

	// 메인 프로시저
	// LRESULT 콜백 반환형
	// 메세지 처리 후 OS에 신호를 주기 위한 값
	// 스위치 문에서 각 메세지에 대한 처리값을 -1, 0, 1로 운영체제에 어떤작업을 해야하는 지 알려주고 0이 뜨면 done
	LRESULT MainProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	//virtual void IFunctionA() = 0;
	//virtual void IFunctionB() = NULL;
	////virtual void IFunctionC() PURE;
	//virtual void IFunctionD() abstract;

	GameNode();
	virtual ~GameNode();
};

/*
순수 가상 함수
 함수의 구현부가 없고 선언부가 = 0으로 끝나는 가상함수를 뜻한다
 부모 클래스에서 순수 가상함수를 선언해 자식 클래스에선 반드시 재정의한 함수를 멤버로 가져와야한다


추상 클래스
 순수 가상함수가 1개 이상있는 클래스를 뜻한다
 객체를 생성할 수 없다 포인터 변수는 가능
 추상클래스는 인스턴스 생성불가
 추상클래스는 자깃클래스를 통해 인스턴스 생성 ㅏ능
 키워드 abstract
 멤버 변수 또는 일반 멤버함수가 포함된 여부와 상관없이 순수 가상함수가 있는 클래스는 추상클래스

C++
class A abstract
{
}

C#
abstract class A
{
}

인터페이스
 순수 가상함수로만 이루어진 클래스 -> 인터페이스
 인터페이스의 개념은 하위클래스에서 반드시 정의해야할 함수를 정해주는 클래스라고 할 수 있다
 c++ 인터페이스라는 개념을 공식적인 키워드로 지원하지 않는다
 표기법 파스칼 케이스

 순수 가상함수 => 상속 -> 기본클래스

특징
 멤버변수 / 함수를 포함할 수없다
 한정자를 사용할 수 없다
 기본 클래스를 상속받을 수 없다
 생성 / 소멸 / 연산 포함이 될 수 없다
 public 속성을 가지고 있어야한다

장점
 다중 상속

단점
 가독성이 떨어짐
 C++ : 강제성이없기에 프로그래머에 의한 실수가 발생할 여지가 많다

가상 소멸자
 동적 클래스 메모리 해제하면 자식 클래스의 소멸자를 호출해야하는데 부모클래스의 소멸자만 호출하는 문제 해결

 호출 순서에 의한 문제를 해결하기 위한 가상 소멸자를 사용해야한다
 이는 메모리 순환 및 잠재적인 오류에 문제점을 방지
 클래스 링크 / 호출 절차에 의한 속도 및 퍼포먼스의 이슈 발생이 있을 수있다
 쓰면 본전은 친다

*/
